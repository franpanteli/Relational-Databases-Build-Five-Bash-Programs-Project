From the first project, `questionnaire.sh`
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

echo hello bash <- to repeat a message back in the terminal 

TO CREATE A SCRIPTING FILE:
	-> touch file_name.sh
	-> Then you can edit the file with commands you want to run in the terminal 
	-> This is as opposed to writing a single Bash command in the terminal <- you write one file with many of them and then run that single file 
		-> When there are many commands in the .sh file, then they will be executed by the terminal in the order which they are listed (from top to bottom)
	-> Then you edit the script file and add the Bash commands into it 
	-> Then you run that in the terminal with sh file_name.sh
		-> You can also use bash file_name.sh
	-> ./questionnaire.sh <- This is an example of how to run one of these files 

TELLING THE COMPUTER WHICH INTERPRETER TO USE:
		-> These are different interpreters 
		-> which bash <- to see the absolute path of the interpreter 
		-> #!<path_to_interpreter> <- add this to the top of the .sh file, so it knows to use the Bash interpreter 
			-> This is a shebang
			-> You get the path_to_interpreter from `which bash` in the terminal 
			-> And then you add this line to the top of the .sh file 
			-> You may need to get rid of 'usr' -> for example '#!/bin/bash', rather than '#!usr/bin/bash'

PERMISSIONS:
	-> To add file permissions 
	-> If you try and run a script and you don't have the file permissions, you will get a 'permission denied' message in the terminal 
	-> ls -l <- to view the file permissions 
		-> This prints out the contents of the current folder and the file permissions for those files 
		-> -rw-r--r-- <- for example, r- read, w- write, x- execute  
	-> To change the file permissions 
		-> chmod +x questionnaire.sh <- To add an 'x' to the file permissions
		-> This allows the users to execute the file 
		-> So now running the file won't return the same permission denied error message 
		-> If you get these error messages, it might be the permissions which you need to change 
	-> Once you have changed the file permissions, you can enter `ls -l` again to check that they have changed 
	-> -rwxr-xr-x <- There are three different types of user, each of these represents the file permission that they have 

TO PRINT THE VALUE OF A VARIABLE:
	-> VARIABLE_NAME=VALUE
	-> For example QUESTION1="What's your name?"
	-> echo $QUESTION1 <- To print (echo) the value ($) of the variable called `QUESTION1`
	-> Then when you run the file in the terminal, the value of this variable will be returned 

TO ADD IN NEW LINES:
	-> echo -e "\n~~ Questionnaire ~~\n" <- To add new lines around a statement which is printed out (echoed) into the terminal 
	-> echo -e "\nHello $NAME from $LOCATION. I learned that your favorite coding website is $WEBSITE!" <- This is another approach used to add new lines 
		-> The statement being printed out here includes the values of variables 

TO TAKE INPUT INTO A VARIABLE:
	-> read VARIABLE_NAME <- Put this into the shell file and then when it is run the terminal will ask the user for input 
		-> The variable will store what the user enters 

HELP:
	-> echo --help <- To see help on the `echo` command 
	-> man echo <- To access the manual for a command 
	-> Control C <- To exit out of the program when it is running in the terminal and you don't want to carry on with it 
	-> If you want help for a command, try `man` and `help`
		-> Some of the commands don't have sections in `man` or `help`
	-> Or help name-of-command
	-> Another example of this is `help [[ expression ]]`
		-> That if there is a piece of code you don't understand, you can just help .... <- with the general syntax of that code 
	-> help [[ <- To see the help menu for the command that (in this example) was previously used (expression)
	-> If you just enter help, then it will query more general parameters -> or the ones which were previously used 

From the second project, `countdown.sh`
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The process:
	-> Create a new .sh file using touch 
	-> Change the file permissions on this using chmod +x filename.sh
	-> This gives you execute permission -> so you can run the file 
	-> Otherwise when you run the command, it will return an error 
	-> Then you edit the file using nano and add a shebang on the top line 
		-> This is telling the terminal which interpreter to use when executing the file 

COMMENTS:
	-> # Comments in Bash look like comments in Python  

TO PRINT OUT THE VALUES OF VARIABLES IN BASH PROGRAMS:
	-> By 'Bash program' <- This means a series of Bash commands in a project .sh file 
	-> You can add arguments to these programs
		-> The values of these can be accessed with $...
	-> echo $* <- This prints out the values of all of the arguments passed into that script 
		-> This is different to the variables 
	-> echo $1 <- To print the first argument which was passed into the script, into the terminal 
		-> You replace 1 with the index of the argument whose value you want to return
		-> This is if you want to print the value of one of the arguments (rather than all of them)
		-> You add this to the project .sh file -> and then when its ran the value of the first argument passed into the program is echoed back out into the terminal  

IF STATEMENTS:

	if [[ CONDITION ]]
	then
 	 STATEMENTS
	fi

	-> (Above) this is an example of an if statement being used in Bash 
	-> An example of a condition is if [[ $1 == arg1 ]]
	-> Another example of this (below):
	
	if [[ $1 == arg1 ]]
	then
	  echo true
	fi

	-> This will return true if arg1 is passed into the script 
	-> To do this, it's ./countdown.sh arg1 <- this is running the script called countdown.sh, with arg1 passed in as an argument 
		-> Running it again without this as an argument will return nothing 

ELSE STATEMENTS:

	if [[ CONDITION ]]
	then
	  STATEMENTS
	else
	  STATEMENTS
	fi

	-> You don't have to add in the else statement 
	-> In the case that the if condition isn't met, you can return an else statement which echoes this 
	-> You can, for example - modify a program to check if an argument is positive (>0), and then print (`echo`) an error message to the terminal if this is the case 

TO PASS ARGUMENTS INTO A PROGRAM:
	-> ./program-name.sh !arg1
	-> ! <- Any argument apart from this one 
	-> arg1 <- The first argument passed into the program 
	-> Instead of (for example) typing !arg1, you type arg2
	-> You are going script-name.sh 4 <- this in the terminal, for example 
		-> To run the script, with the first argument passed into it equal to 4
		-> You can also deliberately test the script with arguments that you know will fail the conditions, to test them 

BOOLEAN STATEMENTS FOR SINGLE CONDITIONS:
	-eq <- Equal
	-ne <- Not equal
	-lt <- Less than
	-le <- Less than or equal
	-gt <- Greater than
	-ge <- Greater than or equal
	-> For example, $1 -lt 5 <- if the first argument is less than 5 

BOOLEAN STATMEENTS FOR MULTIPLE CONDITIONS:
	! <- Is not 
	&& <- This condition and this condition is True 
	|| <- This condition or this condition (you don't use 'or', you use pipes)
	== <- This statement and this statement are both true
	!= <- Is not equal 
	-> You can enter an entire boolean statement into the terminal (e.g [[ 4 -le 5 ]]) <- The terminal is similar to a calculator 
		-> You can just enter boolean statements into it
		-> The answer to this doesn't enter in the terminal <- you just enter the expression, and no results are printed
		-> The results of this boolean expression can be retrieved from echo $?
		-> The result of this is 0 (True)
		-> 1 is False and 0 is True 
		-> This is called the exit status -> and it means that the program had zero errors (rather than that the output is automatically true)

TO ENTER MULTIPLE STATEMENTS ON THE SAME LINE:
	-> To enter multiple statements on the same line, you can separate them with ; 
	-> For example [[ 4 -ge 5 ]]; echo $? <- Is 4 >= to 5, and return the value of the boolean which this produces 
		-> If you didn't return the value of the boolean which that produced, it would be stored in the system memory and could still be accessed with that command 
		-> It's called the exit status 

TO CHECK THE EXIT STATUS OF A COMMAND:
	bad_command; echo $? <- For example, run the command called bad_command (which doesn't exist) and print out its exit statement 
		-> In other words, its value -> which is a 127 error message because the command we ran didn't exist
		-> The exit status is its error message
		-> 0 would mean True (no errors for a boolean statement)
		-> 1 would mean False (errors for a boolean statement) 
		-> Anything apart from 0 is an error message, or that there was some sort of error with the command 
		-> Another example is ls; echo $? <- which returns 0, because it's not a fake command and it's also not a boolean statement with a value of False (there were no errors when dealing with this command)

TO CHECK IF A FILE EXISTS:
	-> [[ -a countdown.sh ]]; echo $? 
		-> We are running two statements in one line 
		-> The first line checks if the file with the name countdown.sh exists
		-> And we are also checking the exit statement of this command
		-> We are seeing if this file exists 

TO CHECK IF YOU HAVE EXECUTE PERMISSION FOR A FILE:
	-> [[ -x countdown.sh ]]; echo $?
		-> This is another example 
		-> x means we have execute permissions for the file 
		-> We are using the ; <- which means, check is we have execute permissions for this file, and run this other line of code at the same time 
		-> The other line of code prints out the exit statement (similar to an error message) of the statement 
		-> So we are saying, check if we have permission to execute this file, and print out the value of the 'boolean' / error message which stores this 
		-> In this example, this returns 0 -> which means that we have execute permissions for the file 
		-> We can run the file without it returning an error message
		-> This is an example of how to implements two conditions on the same line of code 

TO ENTER MULTIPLE BOOLEAN EXPRESSIONS ON THE SAME LINE IN THE TERMINAL:
	-> [[ -x countdown.sh && 5 -le 4 ]]; echo $?
		-> We are combining two boolean statements	
			-> Do we have permission to execute this file 
			-> Is 5 less than or equal to four 
		-> And then we are getting the terminal to print out the exit status of this -> which in this case is the value of the resulting boolean 
		-> 0 being True and 1 being False 













